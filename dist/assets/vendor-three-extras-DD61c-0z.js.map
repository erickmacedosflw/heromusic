{"version":3,"file":"vendor-three-extras-DD61c-0z.js","sources":["../../node_modules/three/examples/jsm/shaders/CopyShader.js","../../node_modules/three/examples/jsm/postprocessing/Pass.js","../../node_modules/three/examples/jsm/postprocessing/ShaderPass.js","../../node_modules/three/examples/jsm/postprocessing/MaskPass.js","../../node_modules/three/examples/jsm/postprocessing/EffectComposer.js","../../node_modules/three/examples/jsm/postprocessing/RenderPass.js","../../node_modules/three/examples/jsm/shaders/BokehShader.js","../../node_modules/three/examples/jsm/postprocessing/BokehPass.js"],"sourcesContent":["/**\n * @module CopyShader\n * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';\n */\n\n/**\n * Full-screen copy shader pass.\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst CopyShader = {\n\n\tname: 'CopyShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\n/**\n * Abstract base class for all post processing passes.\n *\n * This module is only relevant for post processing with {@link WebGLRenderer}.\n *\n * @abstract\n * @three_import import { Pass } from 'three/addons/postprocessing/Pass.js';\n */\nclass Pass {\n\n\t/**\n\t * Constructs a new pass.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isPass = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass is processed by the composer.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.enabled = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass indicates to swap read and write buffer after rendering.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.needsSwap = true;\n\n\t\t/**\n\t\t * If set to `true`, the pass clears its buffer before rendering\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clear = false;\n\n\t\t/**\n\t\t * If set to `true`, the result of the pass is rendered to screen. The last pass in the composers\n\t\t * pass chain gets automatically rendered to screen, no matter how this property is configured.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @abstract\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( /* width, height */ ) {}\n\n\t/**\n\t * This method holds the render logic of a pass. It must be implemented in all derived classes.\n\t *\n\t * @abstract\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t *\n\t * @abstract\n\t */\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\n\n/**\n * This module is a helper for passes which need to render a full\n * screen effect which is quite common in context of post processing.\n *\n * The intended usage is to reuse a single full screen quad for rendering\n * subsequent passes by just reassigning the `material` reference.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * @augments Mesh\n * @three_import import { FullScreenQuad } from 'three/addons/postprocessing/Pass.js';\n */\nclass FullScreenQuad {\n\n\t/**\n\t * Constructs a new full screen quad.\n\t *\n\t * @param {?Material} material - The material to render te full screen quad with.\n\t */\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the instance is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\t/**\n\t * Renders the full screen quad.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t */\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\t/**\n\t * The quad's material.\n\t *\n\t * @type {?Material}\n\t */\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tShaderMaterial,\n\tUniformsUtils\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\n\n/**\n * This pass can be used to create a post processing effect\n * with a raw GLSL shader object. Useful for implementing custom\n * effects.\n *\n * ```js\n * const fxaaPass = new ShaderPass( FXAAShader );\n * composer.addPass( fxaaPass );\n * ```\n *\n * @augments Pass\n * @three_import import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';\n */\nclass ShaderPass extends Pass {\n\n\t/**\n\t * Constructs a new shader pass.\n\t *\n\t * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as\n\t * defines and uniforms. It's also valid to pass a custom shader material.\n\t * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample\n\t * the read buffer.\n\t */\n\tconstructor( shader, textureID = 'tDiffuse' ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The name of the texture uniform that should sample the read buffer.\n\t\t *\n\t\t * @type {string}\n\t\t * @default 'tDiffuse'\n\t\t */\n\t\tthis.textureID = textureID;\n\n\t\t/**\n\t\t * The pass uniforms.\n\t\t *\n\t\t * @type {?Object}\n\t\t */\n\t\tthis.uniforms = null;\n\n\t\t/**\n\t\t * The pass material.\n\t\t *\n\t\t * @type {?ShaderMaterial}\n\t\t */\n\t\tthis.material = null;\n\n\t\tif ( shader instanceof ShaderMaterial ) {\n\n\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\tthis.material = shader;\n\n\t\t} else if ( shader ) {\n\n\t\t\tthis.uniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t\tthis.material = new ShaderMaterial( {\n\n\t\t\t\tname: ( shader.name !== undefined ) ? shader.name : 'unspecified',\n\t\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\t\tuniforms: this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.material );\n\n\t}\n\n\t/**\n\t * Performs the shader pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis._fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\nexport { ShaderPass };\n","import { Pass } from './Pass.js';\n\n/**\n * This pass can be used to define a mask during post processing.\n * Meaning only areas of subsequent post processing are affected\n * which lie in the masking area of this pass. Internally, the masking\n * is implemented with the stencil buffer.\n *\n * ```js\n * const maskPass = new MaskPass( scene, camera );\n * composer.addPass( maskPass );\n * ```\n *\n * @augments Pass\n * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';\n */\nclass MaskPass extends Pass {\n\n\t/**\n\t * Constructs a new mask pass.\n\t *\n\t * @param {Scene} scene - The 3D objects in this scene will define the mask.\n\t * @param {Camera} camera - The camera.\n\t */\n\tconstructor( scene, camera ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene that defines the mask.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * Overwritten to perform a clear operation by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clear = true;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t/**\n\t\t * Whether to inverse the mask or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.inverse = false;\n\n\t}\n\n\t/**\n\t * Performs a mask pass with the configured scene and camera.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst context = renderer.getContext();\n\t\tconst state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tlet writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\tstate.buffers.color.setMask( true );\n\t\tstate.buffers.depth.setMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n}\n\n/**\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\n *\n * ```js\n * const clearPass = new ClearMaskPass();\n * composer.addPass( clearPass );\n * ```\n *\n * @augments Pass\n */\nclass ClearMaskPass extends Pass {\n\n\t/**\n\t * Constructs a new clear mask pass.\n\t */\n\tconstructor() {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t}\n\n\t/**\n\t * Performs the clear of the currently defined mask.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n}\n\nexport { MaskPass, ClearMaskPass };\n","import {\n\tHalfFloatType,\n\tNoBlending,\n\tTimer,\n\tVector2,\n\tWebGLRenderTarget\n} from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { ShaderPass } from './ShaderPass.js';\nimport { ClearMaskPass, MaskPass } from './MaskPass.js';\n\n/**\n * Used to implement post-processing effects in three.js.\n * The class manages a chain of post-processing passes to produce the final visual result.\n * Post-processing passes are executed in order of their addition/insertion.\n * The last pass is automatically rendered to screen.\n *\n * This module can only be used with {@link WebGLRenderer}.\n *\n * ```js\n * const composer = new EffectComposer( renderer );\n *\n * // adding some passes\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n *\n * const glitchPass = new GlitchPass();\n * composer.addPass( glitchPass );\n *\n * const outputPass = new OutputPass()\n * composer.addPass( outputPass );\n *\n * function animate() {\n *\n * \tcomposer.render(); // instead of renderer.render()\n *\n * }\n * ```\n *\n * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\n */\nclass EffectComposer {\n\n\t/**\n\t * Constructs a new effect composer.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\n\t * be used as the internal read and write buffers. If not given, the composer creates\n\t * the buffers automatically.\n\t */\n\tconstructor( renderer, renderTarget ) {\n\n\t\t/**\n\t\t * The renderer.\n\t\t *\n\t\t * @type {WebGLRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = renderer.getSize( new Vector2() );\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t\t} else {\n\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\t/**\n\t\t * A reference to the internal write buffer. Passes usually write\n\t\t * their result into this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.writeBuffer = this.renderTarget1;\n\n\t\t/**\n\t\t * A reference to the internal read buffer. Passes usually read\n\t\t * the previous render result from this buffer.\n\t\t *\n\t\t * @type {WebGLRenderTarget}\n\t\t */\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\t/**\n\t\t * Whether the final pass is rendered to the screen (default framebuffer) or not.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.renderToScreen = true;\n\n\t\t/**\n\t\t * An array representing the (ordered) chain of post-processing passes.\n\t\t *\n\t\t * @type {Array<Pass>}\n\t\t */\n\t\tthis.passes = [];\n\n\t\t/**\n\t\t * A copy pass used for internal swap operations.\n\t\t *\n\t\t * @private\n\t\t * @type {ShaderPass}\n\t\t */\n\t\tthis.copyPass = new ShaderPass( CopyShader );\n\t\tthis.copyPass.material.blending = NoBlending;\n\n\t\t/**\n\t\t * The internal timer for managing time data.\n\t\t *\n\t\t * @private\n\t\t * @type {Timer}\n\t\t */\n\t\tthis.timer = new Timer();\n\n\t}\n\n\t/**\n\t * Swaps the internal read/write buffers.\n\t */\n\tswapBuffers() {\n\n\t\tconst tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t}\n\n\t/**\n\t * Adds the given pass to the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to add.\n\t */\n\taddPass( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Inserts the given pass at a given index.\n\t *\n\t * @param {Pass} pass - The pass to insert.\n\t * @param {number} index - The index into the pass chain.\n\t */\n\tinsertPass( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t}\n\n\t/**\n\t * Removes the given pass from the pass chain.\n\t *\n\t * @param {Pass} pass - The pass to remove.\n\t */\n\tremovePass( pass ) {\n\n\t\tconst index = this.passes.indexOf( pass );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tthis.passes.splice( index, 1 );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\n\t *\n\t * @param {number} passIndex - The pass index.\n\t * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.\n\t */\n\tisLastEnabledPass( passIndex ) {\n\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Executes all enabled post-processing passes in order to produce the final frame.\n\t *\n\t * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\n\t * its own time delta value.\n\t */\n\trender( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tthis.timer.update();\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.timer.getDelta();\n\n\t\t}\n\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tlet maskActive = false;\n\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\n\n\t\t\tconst pass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tconst context = this.renderer.getContext();\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n\t/**\n\t * Resets the internal state of the EffectComposer.\n\t *\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\n\t * the one from the constructor. If set, it is used to setup the read and write buffers.\n\t */\n\treset( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t}\n\n\t/**\n\t * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\n\t * this method honors the current pixel ration.\n\t *\n\t * @param {number} width - The width in logical pixels.\n\t * @param {number} height - The height in logical pixels.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\n\t * Setting the pixel ratio will automatically resize the composer.\n\t *\n\t * @param {number} pixelRatio - The pixel ratio to set.\n\t */\n\tsetPixelRatio( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the composer is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\n\t\tthis.copyPass.dispose();\n\n\t}\n\n}\n\nexport { EffectComposer };\n","import {\n\tColor\n} from 'three';\nimport { Pass } from './Pass.js';\n\n/**\n * This class represents a render pass. It takes a camera and a scene and produces\n * a beauty pass for subsequent post processing effects.\n *\n * ```js\n * const renderPass = new RenderPass( scene, camera );\n * composer.addPass( renderPass );\n * ```\n *\n * @augments Pass\n * @three_import import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';\n */\nclass RenderPass extends Pass {\n\n\t/**\n\t * Constructs a new render pass.\n\t *\n\t * @param {Scene} scene - The scene to render.\n\t * @param {Camera} camera - The camera.\n\t * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used\n\t * for all objects in the scene.\n\t * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.\n\t * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.\n\t */\n\tconstructor( scene, camera, overrideMaterial = null, clearColor = null, clearAlpha = null ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\t/**\n\t\t * The override material. If set, this material is used\n\t\t * for all objects in the scene.\n\t\t *\n\t\t * @type {?Material}\n\t\t * @default null\n\t\t */\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\t/**\n\t\t * The clear color of the render pass.\n\t\t *\n\t\t * @type {?(number|Color|string)}\n\t\t * @default null\n\t\t */\n\t\tthis.clearColor = clearColor;\n\n\t\t/**\n\t\t * The clear alpha of the render pass.\n\t\t *\n\t\t * @type {?number}\n\t\t * @default null\n\t\t */\n\t\tthis.clearAlpha = clearAlpha;\n\n\t\t/**\n\t\t * Overwritten to perform a clear operation by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default true\n\t\t */\n\t\tthis.clear = true;\n\n\t\t/**\n\t\t * If set to `true`, only the depth can be cleared when `clear` is to `false`.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.clearDepth = false;\n\n\t\t/**\n\t\t * Overwritten to disable the swap.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.needsSwap = false;\n\n\t\t/**\n\t\t * This flag indicates that this pass renders the scene itself.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isRenderPass = true;\n\n\t\tthis._oldClearColor = new Color();\n\n\t}\n\n\t/**\n\t * Performs a beauty pass with the configured scene and camera.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tlet oldClearAlpha, oldOverrideMaterial;\n\n\t\tif ( this.overrideMaterial !== null ) {\n\n\t\t\toldOverrideMaterial = this.scene.overrideMaterial;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t}\n\n\t\tif ( this.clearColor !== null ) {\n\n\t\t\trenderer.getClearColor( this._oldClearColor );\n\t\t\trenderer.setClearColor( this.clearColor, renderer.getClearAlpha() );\n\n\t\t}\n\n\t\tif ( this.clearAlpha !== null ) {\n\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\t\t\trenderer.setClearAlpha( this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth == true ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\tif ( this.clear === true ) {\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// restore\n\n\t\tif ( this.clearColor !== null ) {\n\n\t\t\trenderer.setClearColor( this._oldClearColor );\n\n\t\t}\n\n\t\tif ( this.clearAlpha !== null ) {\n\n\t\t\trenderer.setClearAlpha( oldClearAlpha );\n\n\t\t}\n\n\t\tif ( this.overrideMaterial !== null ) {\n\n\t\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t}\n\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n}\n\nexport { RenderPass };\n","/**\n * @module BokehShader\n * @three_import import { BokehShader } from 'three/addons/shaders/BokehShader.js';\n */\n\n/**\n * Depth-of-field shader with bokeh ported from\n * [GLSL shader by Martins Upitis](http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html).\n *\n * @constant\n * @type {ShaderMaterial~Shader}\n */\nconst BokehShader = {\n\n\tname: 'BokehShader',\n\n\tdefines: {\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1,\n\t},\n\n\tuniforms: {\n\n\t\t'tColor': { value: null },\n\t\t'tDepth': { value: null },\n\t\t'focus': { value: 1.0 },\n\t\t'aspect': { value: 1.0 },\n\t\t'aperture': { value: 0.025 },\n\t\t'maxblur': { value: 0.01 },\n\t\t'nearClip': { value: 1.0 },\n\t\t'farClip': { value: 1000.0 },\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColor;\n\t\tuniform sampler2D tDepth;\n\n\t\tuniform float maxblur; // max blur amount\n\t\tuniform float aperture; // aperture - bigger values for shallower depth of field\n\n\t\tuniform float nearClip;\n\t\tuniform float farClip;\n\n\t\tuniform float focus;\n\t\tuniform float aspect;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\t\t\t#if DEPTH_PACKING == 1\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\n\t\t\t#else\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\t\t\t#endif\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\t\t\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#else\n\t\t\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\n\t\t\t#endif\n\t\t}\n\n\n\t\tvoid main() {\n\n\t\t\tvec2 aspectcorrect = vec2( 1.0, aspect );\n\n\t\t\tfloat viewZ = getViewZ( getDepth( vUv ) );\n\n\t\t\tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\n\n\t\t\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\n\n\t\t\tvec2 dofblur9 = dofblur * 0.9;\n\t\t\tvec2 dofblur7 = dofblur * 0.7;\n\t\t\tvec2 dofblur4 = dofblur * 0.4;\n\n\t\t\tvec4 col = vec4( 0.0 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n\t\t\tgl_FragColor = col / 41.0;\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}`\n\n};\n\nexport { BokehShader };\n","import {\n\tColor,\n\tHalfFloatType,\n\tMeshDepthMaterial,\n\tNearestFilter,\n\tNoBlending,\n\tRGBADepthPacking,\n\tShaderMaterial,\n\tUniformsUtils,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { BokehShader } from '../shaders/BokehShader.js';\n\n/**\n * Pass for creating depth of field (DOF) effect.\n *\n * ```js\n * const bokehPass = new BokehPass( scene, camera, {\n * \tfocus: 500\n * \taperture: 5,\n * \tmaxblur: 0.01\n * } );\n * composer.addPass( bokehPass );\n * ```\n *\n * @augments Pass\n * @three_import import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';\n */\nclass BokehPass extends Pass {\n\n\t/**\n\t * Constructs a new Bokeh pass.\n\t *\n\t * @param {Scene} scene - The scene to render the DOF for.\n\t * @param {Camera} camera - The camera.\n\t * @param {BokehPass~Options} params - The pass options.\n\t */\n\tconstructor( scene, camera, params ) {\n\n\t\tsuper();\n\n\t\t/**\n\t\t * The scene to render the DOF for.\n\t\t *\n\t\t * @type {Scene}\n\t\t */\n\t\tthis.scene = scene;\n\n\t\t/**\n\t\t * The camera.\n\t\t *\n\t\t * @type {Camera}\n\t\t */\n\t\tthis.camera = camera;\n\n\t\tconst focus = ( params.focus !== undefined ) ? params.focus : 1.0;\n\t\tconst aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\n\t\tconst maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\n\n\t\t// render targets\n\n\t\tthis._renderTargetDepth = new WebGLRenderTarget( 1, 1, { // will be resized later\n\t\t\tminFilter: NearestFilter,\n\t\t\tmagFilter: NearestFilter,\n\t\t\ttype: HalfFloatType\n\t\t} );\n\n\t\tthis._renderTargetDepth.texture.name = 'BokehPass.depth';\n\n\t\t// depth material\n\n\t\tthis._materialDepth = new MeshDepthMaterial();\n\t\tthis._materialDepth.depthPacking = RGBADepthPacking;\n\t\tthis._materialDepth.blending = NoBlending;\n\n\t\t// bokeh material\n\n\t\tconst bokehUniforms = UniformsUtils.clone( BokehShader.uniforms );\n\n\t\tbokehUniforms[ 'tDepth' ].value = this._renderTargetDepth.texture;\n\n\t\tbokehUniforms[ 'focus' ].value = focus;\n\t\tbokehUniforms[ 'aspect' ].value = camera.aspect;\n\t\tbokehUniforms[ 'aperture' ].value = aperture;\n\t\tbokehUniforms[ 'maxblur' ].value = maxblur;\n\t\tbokehUniforms[ 'nearClip' ].value = camera.near;\n\t\tbokehUniforms[ 'farClip' ].value = camera.far;\n\n\t\t/**\n\t\t * The pass bokeh material.\n\t\t *\n\t\t * @type {ShaderMaterial}\n\t\t */\n\t\tthis.materialBokeh = new ShaderMaterial( {\n\t\t\tdefines: Object.assign( {}, BokehShader.defines ),\n\t\t\tuniforms: bokehUniforms,\n\t\t\tvertexShader: BokehShader.vertexShader,\n\t\t\tfragmentShader: BokehShader.fragmentShader\n\t\t} );\n\n\t\t/**\n\t\t * The pass uniforms.  Use this object if you want to update the\n\t\t * `focus`, `aperture` or `maxblur` values at runtime.\n\t\t *\n\t\t * ```js\n\t\t * pass.uniforms.focus.value = focus;\n\t\t * pass.uniforms.aperture.value = aperture;\n\t\t * pass.uniforms.maxblur.value = maxblur;\n\t\t * ```\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.uniforms = bokehUniforms;\n\n\t\t// internals\n\n\t\tthis._fsQuad = new FullScreenQuad( this.materialBokeh );\n\n\t\tthis._oldClearColor = new Color();\n\n\t}\n\n\t/**\n\t * Performs the Bokeh pass.\n\t *\n\t * @param {WebGLRenderer} renderer - The renderer.\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\n\t * destination for the pass.\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\n\t * previous pass from this buffer.\n\t * @param {number} deltaTime - The delta time in seconds.\n\t * @param {boolean} maskActive - Whether masking is active or not.\n\t */\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\t// Render depth into texture\n\n\t\tthis.scene.overrideMaterial = this._materialDepth;\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tconst oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( 0xffffff );\n\t\trenderer.setClearAlpha( 1.0 );\n\t\trenderer.setRenderTarget( this._renderTargetDepth );\n\t\trenderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// Render bokeh composite\n\n\t\tthis.uniforms[ 'tColor' ].value = readBuffer.texture;\n\t\tthis.uniforms[ 'nearClip' ].value = this.camera.near;\n\t\tthis.uniforms[ 'farClip' ].value = this.camera.far;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis._fsQuad.render( renderer );\n\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\t\trenderer.setClearColor( this._oldClearColor );\n\t\trenderer.setClearAlpha( oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\t/**\n\t * Sets the size of the pass.\n\t *\n\t * @param {number} width - The width to set.\n\t * @param {number} height - The height to set.\n\t */\n\tsetSize( width, height ) {\n\n\t\tthis.materialBokeh.uniforms[ 'aspect' ].value = width / height;\n\n\t\tthis._renderTargetDepth.setSize( width, height );\n\n\t}\n\n\t/**\n\t * Frees the GPU-related resources allocated by this instance. Call this\n\t * method whenever the pass is no longer used in your app.\n\t */\n\tdispose() {\n\n\t\tthis._renderTargetDepth.dispose();\n\n\t\tthis._materialDepth.dispose();\n\t\tthis.materialBokeh.dispose();\n\n\t\tthis._fsQuad.dispose();\n\n\t}\n\n}\n\n/**\n * Constructor options of `BokehPass`.\n *\n * @typedef {Object} BokehPass~Options\n * @property {number} [focus=1] - Defines the effect's focus which is the distance along the camera's look direction in world units.\n * @property {number} [aperture=0.025] - Defines the effect's aperture.\n * @property {number} [maxblur=1] - Defines the effect's maximum blur.\n **/\n\nexport { BokehPass };\n"],"names":["CopyShader","Pass","_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","Float32BufferAttribute","_geometry","FullScreenQuad","material","Mesh","renderer","value","ShaderPass","shader","textureID","ShaderMaterial","UniformsUtils","writeBuffer","readBuffer","MaskPass","scene","camera","context","state","writeValue","clearValue","ClearMaskPass","EffectComposer","renderTarget","size","Vector2","WebGLRenderTarget","HalfFloatType","NoBlending","Timer","tmp","pass","index","passIndex","i","deltaTime","currentRenderTarget","maskActive","il","stencil","width","height","effectiveWidth","effectiveHeight","pixelRatio","RenderPass","overrideMaterial","clearColor","clearAlpha","Color","oldAutoClear","oldClearAlpha","oldOverrideMaterial","BokehShader","BokehPass","params","focus","aperture","maxblur","NearestFilter","MeshDepthMaterial","RGBADepthPacking","bokehUniforms"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}